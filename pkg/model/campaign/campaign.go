package campaign

import (
	"errors"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"plumbus/pkg/util/nums"
	"plumbus/pkg/util/pretty"
	"strings"
	"time"
)

var (
	Table   = "plumbus_fb_campaign"
	Handler = "plumbus_campaignHandler"
)

type Status string

const (
	Active   Status = "ACTIVE"
	Paused   Status = "PAUSED"
	Deleted  Status = "DELETED"
	Archived Status = "ARCHIVED"
)

func (s Status) Param() string {
	return "status=" + s.String()
}

func (s Status) String() string {
	return string(s)
}

func (s Status) Validate() error {
	switch s {
	case Active:
		fallthrough
	case Paused:
		fallthrough
	case Deleted:
		fallthrough
	case Archived:
		return nil
	default:
		return errors.New(fmt.Sprintf("Invalid Status: [%v], must be ACTIVE, PAUSED, DELETED, or ARCHIVED", s))
	}
}

type Entity struct {

	/*
		Keys
	*/

	// AccountID is the partition key; It represents the Account which owns this campaign.
	AccountID string `json:"account_id"`

	// ID is the index key and unique identifier for this entity.
	ID string `json:"id"`

	// CampaignID is the index key and unique identifier for this entity.
	CampaignID string `json:"campaign_id,omitempty"`

	// UTM (Urchin Tracking Module) is a URL parameter used to track the effectiveness of online marketing campaigns.
	// In the case of this entity, the UTM is "sometimes" embedded in the campaign name.
	// In the scope of this system, the UTM is used as a UUID by SOVRN to track Ad revenue.
	UTM string `json:"utm"`

	// Named is the campaign name and effectively a magic string for aggregating data and producing KPI's. GL.
	Named string `json:"name"`

	/*
		FB Description
	*/

	// Stated is an awful workaround for an alleged keyword representing account status.
	Stated Status `json:"status"`

	// DailyBudget is the daily budget of the campaign
	DailyBudget string `json:"daily_budget,omitempty"`

	// BudgetRemaining is the
	BudgetRemaining string `json:"budget_remaining"`

	/*
		FB Insights
	*/

	// Clicks are the number of clicks for campaigns ads.
	Clicks string `json:"clicks"`

	// Impressions represent the number of times campaign ads were on screen.
	Impressions string `json:"impressions"`

	// Spend is the estimated total amount of money spent on this campaign during its schedule.
	Spend string `json:"spend"`

	// CPC is the average cost for each click (all).
	CPC string `json:"cpc"`

	// CPP is the average cost to reach 1,000 people. This metric is estimated.
	CPP string `json:"cpp"`

	// CPM is the average cost for 1,000 impressions.
	CPM string `json:"cpm"`

	// CTR is the percentage of times people saw your ad and performed a click (all).
	CTR string `json:"ctr"`

	/*
		Arbo / Sovrn Tracking Data
	*/

	// Revenue is the amount of (cumulative) revenue generated by campaign ads.
	Revenue float64 `json:"revenue"`

	// Profit is Revenue - Spend ... yeah dingus.
	Profit float64 `json:"profit"`

	// ROI is the return on investment for this campaign expressed as a decimal.
	// ROI decimal value is calculated by dividing Profit by Spend.
	// ROI percentage is calculated by multiplying the decimal value by 100. dummy.
	ROI float64 `json:"roi"`

	/*
		times
	*/

	// Created is the time which this campaign was created.
	Created string `json:"created_time"`

	// Updated is the time which this campaign was updated.
	// Updating the campaign spend_cap, daily budget, or lifetime budget will not automatically update this field.
	Updated string `json:"updated_time"`

	// Refreshed is when this campaign was updated with Arbo or Sovrn tracking data
	Refreshed time.Time `json:"refreshed"`

	/*
		format
	*/
	Formatted Formatted `json:"formatted"`
}

type Node struct {
	// AccountID is the partition key; It represents the Account which owns this campaign.
	AccountID string `json:"account_id"`

	// ID is the index key and unique identifier for this entity.
	ID string `json:"id"`

	// Named is the campaign name and effectively a magic string for aggregating data and producing KPI's. GL.
	Named string `json:"name"`
}

func (e *Entity) SetPerformance() {
	spend := nums.Float64(e.Spend)
	e.Profit = e.Revenue - spend
	if e.Profit == e.Revenue || e.Profit == spend {
		e.ROI = e.Profit * 100
	} else {
		e.ROI = e.Profit / spend * 100
	}
}

func (e *Entity) SetFormat() {
	e.Formatted = Formatted{
		DailyBudget:     pretty.USD(e.DailyBudget, true),
		BudgetRemaining: pretty.USD(e.BudgetRemaining),
		Clicks:          pretty.Int(e.Clicks),
		Impressions:     pretty.Int(e.Impressions),
		Spend:           pretty.USD(e.Spend),
		CPC:             pretty.USD(e.CPC),
		CPP:             pretty.USD(e.CPP),
		CPM:             pretty.USD(e.CPM),
		CTR:             pretty.Percent(e.CTR, 2),
		Revenue:         pretty.USD(e.Revenue),
		Profit:          pretty.USD(e.Profit),
		ROI:             pretty.Percent(e.ROI, 0),
	}
}

func (e *Entity) item() map[string]types.AttributeValue {
	return map[string]types.AttributeValue{
		"ID":              &types.AttributeValueMemberS{Value: e.ID},
		"AccountID":       &types.AttributeValueMemberS{Value: e.AccountID},
		"Named":           &types.AttributeValueMemberS{Value: e.Named},
		"Stated":          &types.AttributeValueMemberS{Value: e.Stated.String()},
		"Created":         &types.AttributeValueMemberS{Value: e.Created},
		"Updated":         &types.AttributeValueMemberS{Value: e.Updated},
		"Refreshed":       &types.AttributeValueMemberS{Value: time.Now().Format(time.RFC3339)},
		"DailyBudget":     &types.AttributeValueMemberS{Value: e.DailyBudget},
		"BudgetRemaining": &types.AttributeValueMemberS{Value: e.BudgetRemaining},
		"Clicks":          &types.AttributeValueMemberS{Value: e.Clicks},
		"Impressions":     &types.AttributeValueMemberS{Value: e.Impressions},
		"Spend":           &types.AttributeValueMemberS{Value: e.Spend},
		"CPC":             &types.AttributeValueMemberS{Value: e.CPC},
		"CPP":             &types.AttributeValueMemberS{Value: e.CPP},
		"CPM":             &types.AttributeValueMemberS{Value: e.CPM},
		"CTR":             &types.AttributeValueMemberS{Value: e.CTR},
		"UTM":             &types.AttributeValueMemberS{Value: e.UTM},
		"Revenue":         &types.AttributeValueMemberN{Value: fmt.Sprintf("%f", e.Revenue)},
		"Profit":          &types.AttributeValueMemberN{Value: fmt.Sprintf("%f", e.Profit)},
		"ROI":             &types.AttributeValueMemberN{Value: fmt.Sprintf("%f", e.ROI)},
	}
}

func (e *Entity) WriteRequest(b ...bool) (wr types.WriteRequest) {
	if b != nil && len(b) > 0 && b[0] {
		wr.DeleteRequest = &types.DeleteRequest{
			Key: map[string]types.AttributeValue{
				"AccountID": &types.AttributeValueMemberS{
					Value: e.AccountID,
				},
				"ID": &types.AttributeValueMemberS{
					Value: e.ID,
				},
			},
		}
	} else {
		wr.PutRequest = &types.PutRequest{
			Item: e.item(),
		}
	}
	return
}

func (e *Entity) Spent() float64 {
	return nums.Float64(e.Spend)
}

func (e *Entity) GetUTM() string {
	if e.UTM != "" {
		return e.UTM
	} else if spaced := strings.Split(e.Named, " "); len(spaced) > 1 && nums.IsNumber(spaced[0]) {
		return spaced[0]
	} else if scored := strings.Split(e.Named, "_"); len(scored) > 1 && nums.IsNumber(scored[0]) {
		return scored[0]
	} else if chunks := strings.Split(e.Named, "("); len(chunks) > 1 {
		if chunks = strings.Split(chunks[1], ")"); len(chunks) > 1 {
			return chunks[0]
		}
	}
	return e.ID
}

func (e *Entity) SetUTM() {
	e.UTM = e.ID
	if spaced := strings.Split(e.Named, " "); len(spaced) > 1 && nums.IsNumber(spaced[0]) {
		e.UTM = spaced[0]
	} else if scored := strings.Split(e.Named, "_"); len(scored) > 1 && nums.IsNumber(scored[0]) {
		e.UTM = scored[0]
	} else if chunks := strings.Split(e.Named, "("); len(chunks) > 1 {
		if chunks = strings.Split(chunks[1], ")"); len(chunks) > 1 {
			e.UTM = chunks[0]
		}
	}
}

type Formatted struct {
	DailyBudget     string `json:"daily_budget"`
	BudgetRemaining string `json:"budget_remaining"`
	Clicks          string `json:"clicks"`
	Impressions     string `json:"impressions"`
	Spend           string `json:"spend"`
	CPC             string `json:"cpc"`
	CPP             string `json:"cpp"`
	CPM             string `json:"cpm"`
	CTR             string `json:"ctr"`
	Revenue         string `json:"revenue"`
	Profit          string `json:"profit"`
	ROI             string `json:"roi"`
}
