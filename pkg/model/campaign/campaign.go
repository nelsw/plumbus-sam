package campaign

import (
	"errors"
	"fmt"
	log "github.com/sirupsen/logrus"
	"plumbus/pkg/util/nums"
	"regexp"
	"strconv"
	"strings"
)

var (
	table        = "plumbus_fb_campaign"
	handler      = "plumbus_campaignHandler"
	statusRegexp = regexp.MustCompile("ACTIVE|PAUSED|DELETED|ARCHIVED")
)

func Table() string {
	return table
}

func TableName() *string {
	return &table
}

func Handler() string {
	return handler
}

type Status string

const (
	Active   Status = "ACTIVE"
	Paused   Status = "PAUSED"
	Deleted  Status = "DELETED"
	Archived Status = "ARCHIVED"
)

func (s Status) Param() string {
	return "status=" + s.String()
}

func (s Status) String() string {
	return string(s)
}

func (s Status) Validate() error {
	if str := s.String(); !statusRegexp.MatchString(str) {
		return errors.New(fmt.Sprintf("Invalid Status: [%s], must be ACTIVE, PAUSED, DELETED, or ARCHIVED", str))
	}
	return nil
}

type Entity struct {

	// AccountID is the partition key; It represents the Account which owns this campaign.
	AccountID string `json:"account_id"`

	// ID is the index key and unique identifier for this entity.
	ID string `json:"id"`

	// Name is exactly what you think it is.
	Name string `json:"name"`

	// Circ is an awful workaround for an alleged keyword representing account status.
	Circ string `json:"status"`

	// Created is the time which this campaign was created.
	Created string `json:"created_time"`

	// Updated is the time which this campaign was updated.
	// Updating the campaign spend_cap, daily budget, or lifetime budget will not automatically update this field.
	Updated string `json:"updated_time"`

	// DailyBudget is the daily budget of the campaign
	DailyBudget string `json:"daily_budget"`

	// BudgetRemaining is the
	BudgetRemaining string `json:"budget_remaining"`

	// Clicks are the number of clicks on this campaigns ads.
	Clicks string `json:"clicks"`

	// Impressions represent the number of times campaign ads were on screen.
	Impressions string `json:"impressions"`

	Spend string `json:"spend"`

	// SpendCap is a spend cap for the campaign, such that it will not spend more than this cap.
	SpendCap string `json:"spend_cap"`

	// CPC is the average cost for each click (all).
	CPC string `json:"cpc"`

	// CPP is the average cost to reach 1,000 people. This metric is estimated.
	CPP string `json:"cpp"`

	// CPM is the average cost for 1,000 impressions.
	CPM string `json:"cpm"`

	// CTR is the percentage of times people saw your ad and performed a click (all).
	CTR string `json:"ctr"`

	// UTM (Urchin Tracking Module) is a URL parameter used to track the effectiveness of online marketing campaigns.
	// In the case of this entity, the UTM is "sometimes" embedded in the campaign name.
	// In the scope of this system, the UTM is used as a UUID by SOVRN to track Ad revenue.
	UTM string `json:"utm"`

	// Revenue is the amount of (cumulative) revenue generated by campaign ads.
	Revenue float64 `json:"revenue,omitempty"`

	// Profit is Revenue - Spend ... yeah dingus.
	Profit float64 `json:"profit,omitempty"`

	// ROI is the return on investment for this campaign expressed as a decimal.
	// ROI decimal value is calculated by dividing Profit by Spend.
	// ROI percentage is calculated by multiplying the decimal value by 100. dummy.
	ROI float64 `json:"roi,omitempty"`
}

func (e *Entity) Spent() float64 {
	f, err := strconv.ParseFloat(e.Spend, 64)
	if err != nil {
		log.WithError(err).Warn("unable to parse float: ", e.Spend)
	}
	return f // 0 or parsed value yeah dummy
}

func (e *Entity) SetUTM() {

	if chunks := strings.Split(e.Name, "("); len(chunks) > 1 {

		if chunks = strings.Split(chunks[1], ")"); len(chunks) > 1 {
			e.UTM = chunks[0]
			return
		}
	}

	if spaced := strings.Split(e.Name, " "); len(spaced) > 1 && nums.IsNumber(spaced[0]) {
		e.UTM = spaced[0]
		return
	}

	if scored := strings.Split(e.Name, "_"); len(scored) > 1 && nums.IsNumber(scored[0]) {
		e.UTM = scored[0]
		return
	}

	e.UTM = e.ID
}
